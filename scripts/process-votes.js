const fs = require('fs');
const https = require('https');

// Add error handling wrapper
process.on('uncaughtException', (error) => {
    console.error('‚ùå FATAL ERROR:', error);
    console.error('Stack trace:', error.stack);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled Rejection at:', promise);
    console.error('Reason:', reason);
    process.exit(1);
});

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const REPO = process.env.GITHUB_REPOSITORY || 'Lewdcifer666/TrueTunes';
const MIN_VOTES = 10;
const MAX_VOTES_PER_USER = 20;

// ===== ADMIN CONFIGURATION =====
const ADMIN_USERS = ['Lewdcifer666'];
const TRUSTED_APP_SIGNATURE = 'Auto-generated by TrueTunes extension';
const REQUIRE_EXTENSION_SIGNATURE = true;
const MIN_ACCOUNT_AGE_DAYS = 7;
const ADMIN_ALLOW_DUPLICATE_VOTES = true;

/**
 * Calculate total votes from reporterVotes (Map or Object)
 * Handles both admin (multiple votes) and regular users (single vote)
 * FIXED: Now handles both Map objects (from live processing) and plain objects (from JSON)
 */
function calculateTotalVotes(reporterVotes) {
    if (!reporterVotes) {
        return 0;
    }

    let total = 0;

    // Handle Map objects (from live processing)
    if (reporterVotes instanceof Map) {
        for (const count of reporterVotes.values()) {
            total += count;
        }
    }
    // Handle plain objects (from loaded JSON - Maps become objects when JSON.parse'd)
    else if (typeof reporterVotes === 'object') {
        for (const count of Object.values(reporterVotes)) {
            total += count;
        }
    }

    return total;
}

console.log('='.repeat(60));
console.log('TrueTunes Vote Processor - Diagnostic Mode');
console.log('='.repeat(60));
console.log('Environment Check:');
console.log(`- Node Version: ${process.version}`);
console.log(`- GITHUB_TOKEN: ${GITHUB_TOKEN ? '‚úì Set' : '‚úó Missing'}`);
console.log(`- REPO: ${REPO}`);
console.log(`- Admin Users: ${ADMIN_USERS.join(', ')}`);
console.log('='.repeat(60));

// Check if data files exist
console.log('\nChecking data files...');
const dataFiles = ['data/flagged.json', 'data/pending.json', 'data/stats.json'];
for (const file of dataFiles) {
    try {
        if (fs.existsSync(file)) {
            const content = fs.readFileSync(file, 'utf8');
            const parsed = JSON.parse(content);
            console.log(`‚úì ${file} - Valid JSON (${Object.keys(parsed).length} keys)`);
        } else {
            console.error(`‚úó ${file} - Not found`);
        }
    } catch (e) {
        console.error(`‚úó ${file} - Error: ${e.message}`);
    }
}

function fetchIssues(state = 'all') {
    return new Promise((resolve, reject) => {
        console.log(`\nüì° Fetching ${state} issues from GitHub API...`);
        const options = {
            hostname: 'api.github.com',
            path: `/repos/${REPO}/issues?labels=vote&state=${state}&per_page=100`,
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.get(options, (res) => {
            console.log(`API Response Status: ${res.statusCode}`);

            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(data);
                    console.log(`‚úì Fetched ${Array.isArray(parsed) ? parsed.length : 0} ${state} issues`);
                    resolve(parsed);
                } catch (e) {
                    console.error('‚úó Failed to parse API response:', e.message);
                    console.error('Response data:', data.substring(0, 500));
                    reject(e);
                }
            });
        });

        req.on('error', (e) => {
            console.error('‚úó API Request Error:', e.message);
            reject(e);
        });

        req.setTimeout(30000, () => {
            req.destroy();
            reject(new Error('API request timeout'));
        });
    });
}

function fetchUserInfo(username) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'api.github.com',
            path: `/users/${username}`,
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.get(options, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    reject(e);
                }
            });
        });

        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('User info request timeout'));
        });
    });
}

function closeIssue(issueNumber, reason = 'processed') {
    return new Promise((resolve, reject) => {
        const postData = JSON.stringify({
            state: 'closed',
            state_reason: 'completed'
        });

        const options = {
            hostname: 'api.github.com',
            path: `/repos/${REPO}/issues/${issueNumber}`,
            method: 'PATCH',
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData),
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    resolve({ status: 'closed' });
                }
            });
        });

        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('Close issue request timeout'));
        });

        req.write(postData);
        req.end();
    });
}

function addCommentToIssue(issueNumber, comment) {
    return new Promise((resolve, reject) => {
        const postData = JSON.stringify({ body: comment });

        const options = {
            hostname: 'api.github.com',
            path: `/repos/${REPO}/issues/${issueNumber}/comments`,
            method: 'POST',
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData),
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    resolve({ status: 'commented' });
                }
            });
        });

        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('Add comment request timeout'));
        });

        req.write(postData);
        req.end();
    });
}

function parseVote(issue) {
    const body = issue.body || '';
    const title = issue.title || '';

    const artistMatch = title.match(/Vote:\s*(.+)/);
    if (!artistMatch) return null;

    const platformMatch = body.match(/Platform:\s*(\w+)/i);
    const idMatch = body.match(/(?:Artist )?ID:\s*([^\s\n]+)/i);
    const voteMatch = body.match(/Vote:\s*ai/i);

    if (!platformMatch || !idMatch || !voteMatch) return null;

    const isFromExtension = body.includes(TRUSTED_APP_SIGNATURE);

    return {
        artist: artistMatch[1].trim(),
        platform: platformMatch[1].toLowerCase(),
        id: idMatch[1].trim(),
        issueNumber: issue.number,
        reporter: issue.user.login,
        isFromExtension: isFromExtension,
        createdAt: issue.created_at
    };
}

async function validateVote(vote) {
    const issues = [];

    if (ADMIN_USERS.includes(vote.reporter)) {
        console.log(`‚úì [ADMIN] ${vote.reporter} - bypassing all checks`);
        return { valid: true, issues: [] };
    }

    if (REQUIRE_EXTENSION_SIGNATURE && !vote.isFromExtension) {
        issues.push('Vote must be submitted through TrueTunes extension');
    }

    try {
        const userInfo = await fetchUserInfo(vote.reporter);
        const accountAge = (Date.now() - new Date(userInfo.created_at)) / (1000 * 60 * 60 * 24);

        if (accountAge < MIN_ACCOUNT_AGE_DAYS) {
            issues.push(`Account must be at least ${MIN_ACCOUNT_AGE_DAYS} days old (current: ${Math.floor(accountAge)} days)`);
        }
    } catch (e) {
        console.error(`Failed to fetch user info for ${vote.reporter}:`, e.message);
        // Don't block on user info fetch failure
    }

    return {
        valid: issues.length === 0,
        issues: issues
    };
}

async function main() {
    try {
        console.log('\n' + '='.repeat(60));
        console.log('Starting vote processing...');
        console.log('='.repeat(60));

        // Fetch BOTH open and recently closed issues for complete picture
        const [openIssues, closedIssues] = await Promise.all([
            fetchIssues('open'),
            fetchIssues('closed')
        ]);

        // Filter closed issues to last 7 days to avoid processing ancient history
        const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
        const recentlyClosed = closedIssues.filter(issue =>
            new Date(issue.closed_at) > sevenDaysAgo
        );

        console.log(`\nüìä Issue Summary:`);
        console.log(`   Open: ${openIssues.length}`);
        console.log(`   Recently Closed: ${recentlyClosed.length}`);

        const issues = openIssues;
        console.log(`\nFound ${issues.length} open vote issues`);

        if (issues.length === 0) {
            console.log('‚úì No votes to process - exiting normally');
            return;
        }

        const flagged = JSON.parse(fs.readFileSync('data/flagged.json', 'utf8'));
        const pending = JSON.parse(fs.readFileSync('data/pending.json', 'utf8'));
        const stats = JSON.parse(fs.readFileSync('data/stats.json', 'utf8'));

        // Snapshot flagged artists at START of run to prevent double-counting
        const preFlaggedArtistIds = new Set(
            flagged.artists.map(a => Object.values(a.platforms)[0])
        );

        // CRITICAL: Declare these arrays BEFORE historical check uses them
        const artistVotes = new Map();
        const invalidIssues = [];
        const duplicateIssues = [];
        const thresholdIssues = [];
        const userVoteCount = new Map();
        const newlyFlaggedIds = new Set(); // Track artists flagged during THIS run

        // Build a complete map of ALL historical votes (including recently closed)
        const allHistoricalIssues = [...openIssues, ...recentlyClosed];
        const historicalVotesByArtist = new Map();

        console.log('\n' + '='.repeat(60));
        console.log('Building Complete Vote History');
        console.log('='.repeat(60));

        for (const issue of allHistoricalIssues) {
            const vote = parseVote(issue);
            if (!vote) continue;

            const key = `${vote.platform}:${vote.id}`;

            if (!historicalVotesByArtist.has(key)) {
                historicalVotesByArtist.set(key, {
                    name: vote.artist,
                    platform: vote.platform,
                    id: vote.id,
                    openIssues: [],
                    closedIssues: [],
                    allReporters: new Set(),
                    reporterVotes: new Map()
                });
            }

            const data = historicalVotesByArtist.get(key);
            data.allReporters.add(vote.reporter);

            if (issue.state === 'open') {
                data.openIssues.push(issue.number);
            } else {
                data.closedIssues.push(issue.number);
            }

            // Count votes per reporter
            const currentCount = data.reporterVotes.get(vote.reporter) || 0;
            data.reporterVotes.set(vote.reporter, currentCount + 1);
        }

        console.log(`\nüìà Historical Vote Summary:`);
        for (const [key, data] of historicalVotesByArtist) {
            const totalVotes = data.openIssues.length + data.closedIssues.length;
            console.log(`   ${data.name}: ${totalVotes} total (${data.openIssues.length} open, ${data.closedIssues.length} closed)`);

            // CRITICAL: If artist has >= 10 total votes but is NOT in flagged.json, flag them now!
            if (totalVotes >= MIN_VOTES) {
                const alreadyFlagged = flagged.artists.some(a =>
                    a.platforms[data.platform] === data.id
                );

                if (!alreadyFlagged) {
                    console.log(`   üö© SHOULD BE FLAGGED: ${data.name} (${totalVotes} votes)`);

                    // Add to flagged
                    const newFlagged = {
                        id: key,
                        name: data.name,
                        platforms: { [data.platform]: data.id },
                        votes: totalVotes,
                        reporters: Array.from(data.allReporters),
                        reporterVotes: Object.fromEntries(data.reporterVotes),
                        added: new Date().toISOString()
                    };

                    flagged.artists.push(newFlagged);

                    // Remove from pending if present
                    pending.artists = pending.artists.filter(a =>
                        a.platforms[data.platform] !== data.id
                    );

                    // Close ALL related issues (open and recently closed that aren't already closed)
                    const allIssuesToClose = [...data.openIssues];
                    thresholdIssues.push(...allIssuesToClose);
                }
            }
        }

        // Track which issues we've processed to prevent duplicates
        const processedIssues = new Set();

        for (const issue of issues) {
            console.log(`\n${'‚îÄ'.repeat(60)}`);

            // Skip if already processed in this run
            if (processedIssues.has(issue.number)) {
                console.log(`‚è≠Ô∏è  Skipping #${issue.number}: Already processed in this run`);
                continue;
            }
            processedIssues.add(issue.number);

            const vote = parseVote(issue);

            if (!vote) {
                console.log(`‚ùå Issue #${issue.number}: Invalid format`);
                invalidIssues.push({ number: issue.number, reason: 'Invalid format' });
                continue;
            }

            // ===== NEW: Check if issue already counted in flagged.json =====
            const alreadyFlagged = flagged.artists.find(a => a.platforms[vote.platform] === vote.id);
            if (alreadyFlagged?.issueNumbers?.includes(issue.number)) {
                console.log(`‚è≠Ô∏è  Skipping #${issue.number}: Already counted in flagged.json for ${vote.artist}`);
                thresholdIssues.push(issue.number); // Auto-close
                continue;
            }

            console.log(`üìã Processing Issue #${issue.number}`);
            console.log(`   Artist: ${vote.artist}`);
            console.log(`   Reporter: ${vote.reporter}`);
            console.log(`   From extension: ${vote.isFromExtension ? '‚úì' : '‚úó'}`);

            const validation = await validateVote(vote);

            if (!validation.valid) {
                console.log(`‚ùå Validation failed:`);
                validation.issues.forEach(issue => console.log(`   - ${issue}`));
                invalidIssues.push({
                    number: issue.number,
                    reason: validation.issues.join('; '),
                    comment: `üö´ **Vote Rejected**\n\n${validation.issues.map(i => `- ${i}`).join('\n')}\n\n*This issue will be closed. Please use the TrueTunes extension to submit votes.*`
                });
                continue;
            }

            // ===== CHECK IF ARTIST IS ALREADY FLAGGED =====
            const artistKey = `${vote.platform}:${vote.id}`;

            // Skip if artist was JUST flagged in this run (votes already counted)
            if (newlyFlaggedIds.has(vote.id)) {
                console.log(`‚è≠Ô∏è  Skipping #${issue.number}: ${vote.artist} was flagged in this run (votes already counted)`);
                thresholdIssues.push(issue.number);
                continue;
            }
            const alreadyFlaggedArtist = flagged.artists.find(a => a.platforms[vote.platform] === vote.id);

            if (alreadyFlaggedArtist) {
                console.log(`‚úì Artist already flagged: ${vote.artist} - adding vote from issue #${issue.number}`);

                // Initialize tracking arrays
                if (!alreadyFlaggedArtist.reporterVotes) alreadyFlaggedArtist.reporterVotes = {};
                if (!alreadyFlaggedArtist.reporters) alreadyFlaggedArtist.reporters = [];
                if (!alreadyFlaggedArtist.issueNumbers) alreadyFlaggedArtist.issueNumbers = [];

                // Add this reporter's vote
                const currentVotes = alreadyFlaggedArtist.reporterVotes[vote.reporter] || 0;
                alreadyFlaggedArtist.reporterVotes[vote.reporter] = currentVotes + 1;

                if (!alreadyFlaggedArtist.reporters.includes(vote.reporter)) {
                    alreadyFlaggedArtist.reporters.push(vote.reporter);
                }

                // Track this issue number
                alreadyFlaggedArtist.issueNumbers.push(issue.number);

                // Recalculate total
                alreadyFlaggedArtist.votes = calculateTotalVotes(alreadyFlaggedArtist.reporterVotes);

                console.log(`   Updated votes: ${alreadyFlaggedArtist.votes}`);
                console.log(`   Tracked issues: ${alreadyFlaggedArtist.issueNumbers.join(', ')}`);

                // Close this issue
                thresholdIssues.push(issue.number);

                continue; // Skip further processing
            }

            if (!ADMIN_USERS.includes(vote.reporter)) {
                const userCount = userVoteCount.get(vote.reporter) || 0;
                if (userCount >= MAX_VOTES_PER_USER) {
                    console.log(`‚ö†Ô∏è  Rate limit exceeded (${userCount}/${MAX_VOTES_PER_USER})`);
                    invalidIssues.push({
                        number: issue.number,
                        reason: 'Rate limit exceeded',
                        comment: `‚ö†Ô∏è **Rate Limit Exceeded**\n\nYou have reached the maximum of ${MAX_VOTES_PER_USER} votes. This issue will be closed.`
                    });
                    continue;
                }
                userVoteCount.set(vote.reporter, userCount + 1);
            }

            const key = `${vote.platform}:${vote.id}`;

            if (!artistVotes.has(key)) {
                artistVotes.set(key, {
                    name: vote.artist,
                    platform: vote.platform,
                    id: vote.id,
                    reporters: new Set(),
                    reporterVotes: new Map(), // ADD THIS LINE
                    issueNumbers: []
                });
            }

            const data = artistVotes.get(key);

            // Initialize reporterVotes Map if not exists
            if (!data.reporterVotes) {
                data.reporterVotes = new Map();
            }

            const isAdmin = ADMIN_USERS.includes(vote.reporter);
            const allowDuplicate = isAdmin && ADMIN_ALLOW_DUPLICATE_VOTES;

            if (data.reporters.has(vote.reporter) && !allowDuplicate) {
                console.log(`‚ö†Ô∏è  Duplicate vote detected`);
                duplicateIssues.push({
                    number: issue.number,
                    comment: `‚ÑπÔ∏è **Duplicate Vote**\n\nYou have already voted for **${vote.artist}**. This duplicate will be closed.`
                });
            } else {
                if (allowDuplicate) {
                    // Admin: Count each vote separately
                    const voteCount = data.reporterVotes.get(vote.reporter) || 0;
                    data.reporterVotes.set(vote.reporter, voteCount + 1);
                    data.reporters.add(vote.reporter); // Still track unique reporter
                    console.log(`‚úì [ADMIN] Vote #${voteCount + 1} counted for ${vote.artist}`);
                } else {
                    // Regular user: One vote per artist
                    data.reporters.add(vote.reporter);
                    data.reporterVotes.set(vote.reporter, 1);
                    console.log(`‚úì Vote counted`);
                }

                data.issueNumbers.push(issue.number);

                // Calculate total votes (sum of all vote counts)
                let totalVotes = 0;
                for (const count of data.reporterVotes.values()) {
                    totalVotes += count;
                }
                console.log(`   Total votes for ${vote.artist}: ${totalVotes}`);
            }
        }



        console.log('\n' + '='.repeat(60));
        console.log('Updating Pending Artists');
        console.log('='.repeat(60));

        for (const [key, data] of artistVotes) {
            // CRITICAL FIX: Skip artists already flagged by historical check
            const alreadyFlagged = flagged.artists.some(a =>
                a.platforms[data.platform] === data.id
            );

            if (alreadyFlagged) {
                console.log(`\n‚è≠Ô∏è  Skipped: ${data.name} (already flagged)`);
                continue;
            }

            const existing = pending.artists.find(a =>
                a.platforms[data.platform] === data.id
            );

            if (existing) {
                // FIXED: Track which issues have been counted to prevent duplicate counting
                const existingIssues = new Set(existing.issueNumbers || []);
                const newIssues = data.issueNumbers.filter(num => !existingIssues.has(num));

                if (newIssues.length === 0) {
                    console.log(`\n‚è≠Ô∏è  Skipped: ${data.name} (all issues already counted)`);
                    continue;
                }

                console.log(`\nüìù Updating: ${data.name} (${newIssues.length} new issues)`);

                // Only count votes from NEW issues
                const existingReporters = new Set(existing.reporters || []);

                // Find reporters from new issues only
                const newReporters = new Set();
                for (const issueNumber of newIssues) {
                    const issue = issues.find(i => i.number === issueNumber);
                    if (issue) {
                        const vote = parseVote(issue);
                        if (vote) {
                            newReporters.add(vote.reporter);
                        }
                    }
                }

                // Merge reporters
                newReporters.forEach(reporter => existingReporters.add(reporter));
                existing.reporters = Array.from(existingReporters);

                // Merge issue numbers
                existing.issueNumbers = Array.from(new Set([...existingIssues, ...newIssues]));

                // CRITICAL FIX: Merge reporterVotes only for NEW issues
                const mergedVotes = new Map();

                // Load existing votes from pending.json
                if (existing.reporterVotes) {
                    Object.entries(existing.reporterVotes).forEach(([reporter, count]) => {
                        mergedVotes.set(reporter, count);
                    });
                }

                // Add votes ONLY from new issues
                for (const issueNumber of newIssues) {
                    const issue = issues.find(i => i.number === issueNumber);
                    if (issue) {
                        const vote = parseVote(issue);
                        if (vote) {
                            const reporter = vote.reporter;
                            const currentCount = mergedVotes.get(reporter) || 0;

                            // Cap at MAX_VOTES_PER_USER (or unlimited for admins)
                            if (ADMIN_USERS.includes(reporter)) {
                                mergedVotes.set(reporter, currentCount + 1);
                            } else {
                                mergedVotes.set(reporter, Math.min(currentCount + 1, MAX_VOTES_PER_USER));
                            }
                        }
                    }
                }

                // Calculate total and update
                const totalVotes = calculateTotalVotes(mergedVotes);
                existing.votes = totalVotes;
                existing.reporterVotes = Object.fromEntries(mergedVotes);

                console.log(`   Unique reporters: ${existing.reporters.length}`);
                console.log(`   Total votes: ${existing.votes}/${MIN_VOTES}`);
                console.log(`   Tracked issues: ${existing.issueNumbers.join(', ')}`);

                // NEW: Check if this update pushed it over threshold
                if (totalVotes >= MIN_VOTES) {
                    console.log(`   üéØ THRESHOLD REACHED!`);
                }
            } else {
                // New artist
                const newArtist = {
                    id: key,
                    name: data.name,
                    platforms: { [data.platform]: data.id },
                    votes: calculateTotalVotes(data.reporterVotes || new Map()),
                    reporters: Array.from(data.reporters),
                    reporterVotes: Object.fromEntries(data.reporterVotes || new Map()),
                    issueNumbers: data.issueNumbers, // ADDED: Track which issues were counted
                    added: new Date().toISOString()
                };
                pending.artists.push(newArtist);
                console.log(`\n‚ûï Added: ${data.name}`);
                console.log(`   Votes: ${newArtist.votes}/${MIN_VOTES}`);
            }
        }

        console.log('\n' + '='.repeat(60));
        console.log('Processing Threshold Artists');
        console.log('='.repeat(60));

        const now = new Date().toISOString();
        let newlyFlagged = 0;


        pending.artists = pending.artists.filter(artist => {
            // FIXED: Calculate total votes using helper function that handles both Maps and Objects
            const totalVotes = calculateTotalVotes(artist.reporterVotes || {});

            if (totalVotes >= MIN_VOTES) {
                artist.votes = totalVotes; // Update with calculated total

                // Ensure issueNumbers is included when moving to flagged
                if (!artist.issueNumbers) {
                    artist.issueNumbers = [];
                }

                newlyFlagged++;
                console.log(`\nüö© FLAGGED: ${artist.name}`);
                console.log(`   Final vote count: ${artist.votes}`);

                // Track this artist as newly flagged
                const artistId = Object.values(artist.platforms)[0];
                newlyFlaggedIds.add(artistId);

                const artistKey = artist.id;
                if (artistVotes.has(artistKey)) {
                    const artistData = artistVotes.get(artistKey);
                    thresholdIssues.push(...artistData.issueNumbers);
                    console.log(`   Closing ${artistData.issueNumbers.length} related issues`);
                    console.log(`   Issue numbers: ${artistData.issueNumbers.join(', ')}`);
                }

                return false;
            }
            return true;
        });

        stats.totalArtists = flagged.artists.length + pending.artists.length;
        stats.flaggedArtists = flagged.artists.length;
        stats.votesToday = invalidIssues.length + duplicateIssues.length + thresholdIssues.length;
        stats.votesTotal += stats.votesToday;
        stats.lastUpdated = now;

        flagged.version = now;
        flagged.updated = now;
        flagged.total = flagged.artists.length;

        pending.version = now;
        pending.updated = now;

        console.log('\n' + '='.repeat(60));
        console.log('Saving data files...');
        console.log('='.repeat(60));

        fs.writeFileSync('data/flagged.json', JSON.stringify(flagged, null, 2));
        console.log('‚úì Saved flagged.json');

        fs.writeFileSync('data/pending.json', JSON.stringify(pending, null, 2));
        console.log('‚úì Saved pending.json');

        fs.writeFileSync('data/stats.json', JSON.stringify(stats, null, 2));
        console.log('‚úì Saved stats.json');

        // VALIDATION: Check for inconsistencies
        console.log('\n' + '='.repeat(60));
        console.log('VALIDATION CHECK');
        console.log('='.repeat(60));

        for (const artist of pending.artists) {
            const artistId = Object.values(artist.platforms)[0];
            const key = artist.id;

            // Check if this pending artist actually has enough votes to be flagged
            const historical = historicalVotesByArtist.get(key);
            if (historical) {
                const totalVotes = historical.openIssues.length + historical.closedIssues.length;
                if (totalVotes >= MIN_VOTES) {
                    console.log(`‚ö†Ô∏è  WARNING: ${artist.name} in pending with ${artist.votes} recorded votes, but has ${totalVotes} total votes!`);
                }
            }
        }

        console.log('‚úì Validation complete');

        console.log('\n' + '='.repeat(60));
        console.log('SUMMARY');
        console.log('='.repeat(60));
        console.log(`Total issues processed: ${issues.length}`);
        console.log(`Newly flagged artists: ${newlyFlagged}`);
        console.log(`Pending artists: ${pending.artists.length}`);
        console.log(`Total flagged artists: ${flagged.artists.length}`);
        console.log(`\nIssues to close:`);
        console.log(`  - Invalid: ${invalidIssues.length}`);
        console.log(`  - Duplicates: ${duplicateIssues.length}`);
        console.log(`  - Threshold reached: ${thresholdIssues.length}`);

        console.log('\n' + '='.repeat(60));
        console.log('Closing issues...');
        console.log('='.repeat(60));

        // Group threshold issues by artist for better comments
        const issuesByArtist = new Map();
        for (const issueNumber of thresholdIssues) {
            // Find which artist this issue belongs to
            const issue = issues.find(i => i.number === issueNumber);
            if (issue) {
                const vote = parseVote(issue);
                if (vote) {
                    if (!issuesByArtist.has(vote.artist)) {
                        issuesByArtist.set(vote.artist, []);
                    }
                    issuesByArtist.get(vote.artist).push(issueNumber);
                }
            }
        }

        // Close issues by artist with informative comments
        for (const [artistName, issueNumbers] of issuesByArtist) {
            console.log(`\nüö© Closing ${issueNumbers.length} issues for: ${artistName}`);

            for (const issueNumber of issueNumbers) {
                try {
                    // Add comment before closing
                    await addCommentToIssue(issueNumber,
                        `‚úÖ **Threshold Reached!**\n\n` +
                        `**${artistName}** has been flagged with 10+ community votes.\n\n` +
                        `All ${issueNumbers.length} related issues are being closed.\n\n` +
                        `The artist is now listed in [flagged.json](https://github.com/${REPO}/blob/main/data/flagged.json).`
                    );
                    console.log(`   ‚úì Added comment to #${issueNumber}`);

                    // Close the issue
                    await closeIssue(issueNumber, 'completed');
                    console.log(`   ‚úì Closed #${issueNumber}`);
                } catch (e) {
                    console.error(`   ‚úó Failed to close #${issueNumber}:`, e.message);
                }
            }
        }

        for (const invalid of invalidIssues) {
            try {
                if (invalid.comment) {
                    await addCommentToIssue(invalid.number, invalid.comment);
                    console.log(`‚úì Added comment to #${invalid.number}`);
                }
                await closeIssue(invalid.number, 'not_planned');
                console.log(`‚úì Closed #${invalid.number}: ${invalid.reason}`);
            } catch (e) {
                console.error(`‚úó Failed to close #${invalid.number}:`, e.message);
            }
        }

        for (const duplicate of duplicateIssues) {
            try {
                if (duplicate.comment) {
                    await addCommentToIssue(duplicate.number, duplicate.comment);
                    console.log(`‚úì Added comment to #${duplicate.number}`);
                }
                await closeIssue(duplicate.number, 'not_planned');
                console.log(`‚úì Closed #${duplicate.number}: Duplicate vote`);
            } catch (e) {
                console.error(`‚úó Failed to close #${duplicate.number}:`, e.message);
            }
        }

        for (const issueNumber of thresholdIssues) {
            try {
                await closeIssue(issueNumber, 'completed');
                console.log(`‚úì Closed #${issueNumber}: Artist flagged`);
            } catch (e) {
                console.error(`‚úó Failed to close #${issueNumber}:`, e.message);
            }
        }

        console.log('\n' + '='.repeat(60));
        console.log('‚úÖ Processing complete!');
        console.log('='.repeat(60));

    } catch (error) {
        console.error('\n' + '='.repeat(60));
        console.error('‚ùå FATAL ERROR');
        console.error('='.repeat(60));
        console.error('Error:', error.message);
        console.error('Stack:', error.stack);
        throw error;
    }
}

main().catch(error => {
    console.error('\n‚ùå Script failed:', error);
    process.exit(1);
});