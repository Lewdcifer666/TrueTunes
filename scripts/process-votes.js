const fs = require('fs');
const https = require('https');

// Add error handling wrapper
process.on('uncaughtException', (error) => {
    console.error('‚ùå FATAL ERROR:', error);
    console.error('Stack trace:', error.stack);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled Rejection at:', promise);
    console.error('Reason:', reason);
    process.exit(1);
});

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const REPO = process.env.GITHUB_REPOSITORY || 'Lewdcifer666/TrueTunes';
const MIN_VOTES = 10;
const MAX_VOTES_PER_USER = 20;

// ===== ADMIN CONFIGURATION =====
const ADMIN_USERS = ['Lewdcifer666'];
const TRUSTED_APP_SIGNATURE = 'Auto-generated by TrueTunes extension';
const REQUIRE_EXTENSION_SIGNATURE = true;
const MIN_ACCOUNT_AGE_DAYS = 7;
const ADMIN_ALLOW_DUPLICATE_VOTES = true;

console.log('='.repeat(60));
console.log('TrueTunes Vote Processor - Diagnostic Mode');
console.log('='.repeat(60));
console.log('Environment Check:');
console.log(`- Node Version: ${process.version}`);
console.log(`- GITHUB_TOKEN: ${GITHUB_TOKEN ? '‚úì Set' : '‚úó Missing'}`);
console.log(`- REPO: ${REPO}`);
console.log(`- Admin Users: ${ADMIN_USERS.join(', ')}`);
console.log('='.repeat(60));

// Check if data files exist
console.log('\nChecking data files...');
const dataFiles = ['data/flagged.json', 'data/pending.json', 'data/stats.json'];
for (const file of dataFiles) {
    try {
        if (fs.existsSync(file)) {
            const content = fs.readFileSync(file, 'utf8');
            const parsed = JSON.parse(content);
            console.log(`‚úì ${file} - Valid JSON (${Object.keys(parsed).length} keys)`);
        } else {
            console.error(`‚úó ${file} - Not found`);
        }
    } catch (e) {
        console.error(`‚úó ${file} - Error: ${e.message}`);
    }
}

function fetchIssues() {
    return new Promise((resolve, reject) => {
        console.log('\nüì° Fetching issues from GitHub API...');
        const options = {
            hostname: 'api.github.com',
            path: `/repos/${REPO}/issues?labels=vote&state=open&per_page=100`,
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.get(options, (res) => {
            console.log(`API Response Status: ${res.statusCode}`);

            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(data);
                    console.log(`‚úì Fetched ${Array.isArray(parsed) ? parsed.length : 0} issues`);
                    resolve(parsed);
                } catch (e) {
                    console.error('‚úó Failed to parse API response:', e.message);
                    console.error('Response data:', data.substring(0, 500));
                    reject(e);
                }
            });
        });

        req.on('error', (e) => {
            console.error('‚úó API Request Error:', e.message);
            reject(e);
        });

        req.setTimeout(30000, () => {
            req.destroy();
            reject(new Error('API request timeout'));
        });
    });
}

function fetchUserInfo(username) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'api.github.com',
            path: `/users/${username}`,
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.get(options, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    reject(e);
                }
            });
        });

        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('User info request timeout'));
        });
    });
}

function closeIssue(issueNumber, reason = 'processed') {
    return new Promise((resolve, reject) => {
        const postData = JSON.stringify({
            state: 'closed',
            state_reason: 'completed'
        });

        const options = {
            hostname: 'api.github.com',
            path: `/repos/${REPO}/issues/${issueNumber}`,
            method: 'PATCH',
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData),
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    resolve({ status: 'closed' });
                }
            });
        });

        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('Close issue request timeout'));
        });

        req.write(postData);
        req.end();
    });
}

function addCommentToIssue(issueNumber, comment) {
    return new Promise((resolve, reject) => {
        const postData = JSON.stringify({ body: comment });

        const options = {
            hostname: 'api.github.com',
            path: `/repos/${REPO}/issues/${issueNumber}/comments`,
            method: 'POST',
            headers: {
                'User-Agent': 'TrueTunes-Bot',
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData),
                'Accept': 'application/vnd.github.v3+json'
            }
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    resolve({ status: 'commented' });
                }
            });
        });

        req.on('error', reject);
        req.setTimeout(10000, () => {
            req.destroy();
            reject(new Error('Add comment request timeout'));
        });

        req.write(postData);
        req.end();
    });
}

function parseVote(issue) {
    const body = issue.body || '';
    const title = issue.title || '';

    const artistMatch = title.match(/Vote:\s*(.+)/);
    if (!artistMatch) return null;

    const platformMatch = body.match(/Platform:\s*(\w+)/i);
    const idMatch = body.match(/(?:Artist )?ID:\s*([^\s\n]+)/i);
    const voteMatch = body.match(/Vote:\s*ai/i);

    if (!platformMatch || !idMatch || !voteMatch) return null;

    const isFromExtension = body.includes(TRUSTED_APP_SIGNATURE);

    return {
        artist: artistMatch[1].trim(),
        platform: platformMatch[1].toLowerCase(),
        id: idMatch[1].trim(),
        issueNumber: issue.number,
        reporter: issue.user.login,
        isFromExtension: isFromExtension,
        createdAt: issue.created_at
    };
}

async function validateVote(vote) {
    const issues = [];

    if (ADMIN_USERS.includes(vote.reporter)) {
        console.log(`‚úì [ADMIN] ${vote.reporter} - bypassing all checks`);
        return { valid: true, issues: [] };
    }

    if (REQUIRE_EXTENSION_SIGNATURE && !vote.isFromExtension) {
        issues.push('Vote must be submitted through TrueTunes extension');
    }

    try {
        const userInfo = await fetchUserInfo(vote.reporter);
        const accountAge = (Date.now() - new Date(userInfo.created_at)) / (1000 * 60 * 60 * 24);

        if (accountAge < MIN_ACCOUNT_AGE_DAYS) {
            issues.push(`Account must be at least ${MIN_ACCOUNT_AGE_DAYS} days old (current: ${Math.floor(accountAge)} days)`);
        }
    } catch (e) {
        console.error(`Failed to fetch user info for ${vote.reporter}:`, e.message);
        // Don't block on user info fetch failure
    }

    return {
        valid: issues.length === 0,
        issues: issues
    };
}

async function main() {
    try {
        console.log('\n' + '='.repeat(60));
        console.log('Starting vote processing...');
        console.log('='.repeat(60));

        const issues = await fetchIssues();
        console.log(`\nFound ${issues.length} open vote issues`);

        if (issues.length === 0) {
            console.log('‚úì No votes to process - exiting normally');
            return;
        }

        const flagged = JSON.parse(fs.readFileSync('data/flagged.json', 'utf8'));
        const pending = JSON.parse(fs.readFileSync('data/pending.json', 'utf8'));
        const stats = JSON.parse(fs.readFileSync('data/stats.json', 'utf8'));

        const artistVotes = new Map();
        const invalidIssues = [];
        const duplicateIssues = [];
        const thresholdIssues = [];
        const userVoteCount = new Map();

        for (const issue of issues) {
            console.log(`\n${'‚îÄ'.repeat(60)}`);
            const vote = parseVote(issue);

            if (!vote) {
                console.log(`‚ùå Issue #${issue.number}: Invalid format`);
                invalidIssues.push({ number: issue.number, reason: 'Invalid format' });
                continue;
            }

            console.log(`üìã Processing Issue #${issue.number}`);
            console.log(`   Artist: ${vote.artist}`);
            console.log(`   Reporter: ${vote.reporter}`);
            console.log(`   From extension: ${vote.isFromExtension ? '‚úì' : '‚úó'}`);

            const validation = await validateVote(vote);

            if (!validation.valid) {
                console.log(`‚ùå Validation failed:`);
                validation.issues.forEach(issue => console.log(`   - ${issue}`));
                invalidIssues.push({
                    number: issue.number,
                    reason: validation.issues.join('; '),
                    comment: `üö´ **Vote Rejected**\n\n${validation.issues.map(i => `- ${i}`).join('\n')}\n\n*This issue will be closed. Please use the TrueTunes extension to submit votes.*`
                });
                continue;
            }

            if (!ADMIN_USERS.includes(vote.reporter)) {
                const userCount = userVoteCount.get(vote.reporter) || 0;
                if (userCount >= MAX_VOTES_PER_USER) {
                    console.log(`‚ö†Ô∏è  Rate limit exceeded (${userCount}/${MAX_VOTES_PER_USER})`);
                    invalidIssues.push({
                        number: issue.number,
                        reason: 'Rate limit exceeded',
                        comment: `‚ö†Ô∏è **Rate Limit Exceeded**\n\nYou have reached the maximum of ${MAX_VOTES_PER_USER} votes. This issue will be closed.`
                    });
                    continue;
                }
                userVoteCount.set(vote.reporter, userCount + 1);
            }

            const key = `${vote.platform}:${vote.id}`;

            if (!artistVotes.has(key)) {
                artistVotes.set(key, {
                    name: vote.artist,
                    platform: vote.platform,
                    id: vote.id,
                    reporters: new Set(),
                    issueNumbers: []
                });
            }

            const data = artistVotes.get(key);

            const isAdmin = ADMIN_USERS.includes(vote.reporter);
            const allowDuplicate = isAdmin && ADMIN_ALLOW_DUPLICATE_VOTES;

            if (data.reporters.has(vote.reporter) && !allowDuplicate) {
                console.log(`‚ö†Ô∏è  Duplicate vote detected`);
                duplicateIssues.push({
                    number: issue.number,
                    comment: `‚ÑπÔ∏è **Duplicate Vote**\n\nYou have already voted for **${vote.artist}**. This duplicate will be closed.`
                });
            } else {
                if (allowDuplicate) {
                    // Admin: Count each vote separately
                    const voteCount = data.reporterVotes.get(vote.reporter) || 0;
                    data.reporterVotes.set(vote.reporter, voteCount + 1);
                    console.log(`‚úì [ADMIN] Vote #${voteCount + 1} counted for ${vote.artist}`);
                } else {
                    // Regular user: One vote per artist
                    data.reporters.add(vote.reporter);
                    data.reporterVotes.set(vote.reporter, 1);
                    console.log(`‚úì Vote counted`);
                }

                data.issueNumbers.push(issue.number);

                // Calculate total votes
                let totalVotes = 0;
                for (const count of data.reporterVotes.values()) {
                    totalVotes += count;
                }
                console.log(`   Total votes for ${vote.artist}: ${totalVotes}`);
            }
        }



        console.log('\n' + '='.repeat(60));
        console.log('Updating Pending Artists');
        console.log('='.repeat(60));

        for (const [key, data] of artistVotes) {
            const existing = pending.artists.find(a =>
                a.platforms[data.platform] === data.id
            );

            if (existing) {
                const existingReporters = new Set(existing.reporters || []);
                data.reporters.forEach(reporter => existingReporters.add(reporter));
                existing.reporters = Array.from(existingReporters);
                existing.votes = existing.reporters.length;
                console.log(`\nüìù Updated: ${data.name}`);
                console.log(`   Votes: ${existing.votes}/${MIN_VOTES}`);
            } else {
                const newArtist = {
                    id: key,
                    name: data.name,
                    platforms: { [data.platform]: data.id },
                    votes: data.reporters.size,
                    reporters: Array.from(data.reporters),
                    added: new Date().toISOString()
                };
                pending.artists.push(newArtist);
                console.log(`\n‚ûï Added: ${data.name}`);
                console.log(`   Votes: ${newArtist.votes}/${MIN_VOTES}`);
            }
        }

        console.log('\n' + '='.repeat(60));
        console.log('Processing Threshold Artists');
        console.log('='.repeat(60));

        const now = new Date().toISOString();
        let newlyFlagged = 0;

        pending.artists = pending.artists.filter(artist => {
            if (artist.votes >= MIN_VOTES) {
                flagged.artists.push(artist);
                newlyFlagged++;
                console.log(`\nüö© FLAGGED: ${artist.name}`);
                console.log(`   Final vote count: ${artist.votes}`);

                const artistKey = artist.id;
                if (artistVotes.has(artistKey)) {
                    const artistData = artistVotes.get(artistKey);
                    thresholdIssues.push(...artistData.issueNumbers);
                    console.log(`   Closing ${artistData.issueNumbers.length} related issues`);
                }

                return false;
            }
            return true;
        });

        stats.totalArtists = flagged.artists.length + pending.artists.length;
        stats.flaggedArtists = flagged.artists.length;
        stats.votesToday = invalidIssues.length + duplicateIssues.length + thresholdIssues.length;
        stats.votesTotal += stats.votesToday;
        stats.lastUpdated = now;

        flagged.version = now;
        flagged.updated = now;
        flagged.total = flagged.artists.length;

        pending.version = now;
        pending.updated = now;

        console.log('\n' + '='.repeat(60));
        console.log('Saving data files...');
        console.log('='.repeat(60));

        fs.writeFileSync('data/flagged.json', JSON.stringify(flagged, null, 2));
        console.log('‚úì Saved flagged.json');

        fs.writeFileSync('data/pending.json', JSON.stringify(pending, null, 2));
        console.log('‚úì Saved pending.json');

        fs.writeFileSync('data/stats.json', JSON.stringify(stats, null, 2));
        console.log('‚úì Saved stats.json');

        console.log('\n' + '='.repeat(60));
        console.log('SUMMARY');
        console.log('='.repeat(60));
        console.log(`Total issues processed: ${issues.length}`);
        console.log(`Newly flagged artists: ${newlyFlagged}`);
        console.log(`Pending artists: ${pending.artists.length}`);
        console.log(`Total flagged artists: ${flagged.artists.length}`);
        console.log(`\nIssues to close:`);
        console.log(`  - Invalid: ${invalidIssues.length}`);
        console.log(`  - Duplicates: ${duplicateIssues.length}`);
        console.log(`  - Threshold reached: ${thresholdIssues.length}`);

        console.log('\n' + '='.repeat(60));
        console.log('Closing issues...');
        console.log('='.repeat(60));

        for (const invalid of invalidIssues) {
            try {
                if (invalid.comment) {
                    await addCommentToIssue(invalid.number, invalid.comment);
                    console.log(`‚úì Added comment to #${invalid.number}`);
                }
                await closeIssue(invalid.number, 'not_planned');
                console.log(`‚úì Closed #${invalid.number}: ${invalid.reason}`);
            } catch (e) {
                console.error(`‚úó Failed to close #${invalid.number}:`, e.message);
            }
        }

        for (const duplicate of duplicateIssues) {
            try {
                if (duplicate.comment) {
                    await addCommentToIssue(duplicate.number, duplicate.comment);
                    console.log(`‚úì Added comment to #${duplicate.number}`);
                }
                await closeIssue(duplicate.number, 'not_planned');
                console.log(`‚úì Closed #${duplicate.number}: Duplicate vote`);
            } catch (e) {
                console.error(`‚úó Failed to close #${duplicate.number}:`, e.message);
            }
        }

        for (const issueNumber of thresholdIssues) {
            try {
                await closeIssue(issueNumber, 'completed');
                console.log(`‚úì Closed #${issueNumber}: Artist flagged`);
            } catch (e) {
                console.error(`‚úó Failed to close #${issueNumber}:`, e.message);
            }
        }

        console.log('\n' + '='.repeat(60));
        console.log('‚úÖ Processing complete!');
        console.log('='.repeat(60));

    } catch (error) {
        console.error('\n' + '='.repeat(60));
        console.error('‚ùå FATAL ERROR');
        console.error('='.repeat(60));
        console.error('Error:', error.message);
        console.error('Stack:', error.stack);
        throw error;
    }
}

main().catch(error => {
    console.error('\n‚ùå Script failed:', error);
    process.exit(1);
});